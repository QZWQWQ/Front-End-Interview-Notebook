## 跨域

### （1）CORS

CORS（Corss-Origin Resource Sharing，跨资源共享）基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。

### （2）Jsonp

```js
// JSONP由两部分组成：回调函数和数据
// 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。
// 数据是传入回调函数中的JSON数据。
var script=document.createElement("script");
script.src="url?callback=handleResponse";
document.body.insertBefore(script,document.body.firstChild);
```

优点：不像`XMLHttpRequest`对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果

缺点：只支持GET请求而不支持POST等其它类型的HTTP请求；只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行`JavaScript`调用的问题。JSONP从其他域中加载代码执行，其他域可能不安全；难以确定JSONP请求是否失败。

### （2）document.domain

主域相同，子域不同，可以设置document.domain来解决跨域。将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。

注意：不能将值设置为URL中不包含的域；松散的域名不能再设置为紧绷的域名。

```javascript
// 在www.a.com/a.html中
document.domain = 'a.com';
var ifr = document.createElement('iframe');
ifr.src = 'http://www.script.a.com/b.html';
ifr.display = none;
document.body.appendChild(ifr);
ifr.onload = function(){
    var doc = ifr.contentDocument || ifr.contentWindow.document;
    //在这里操作doc，也就是b.html
    ifr.onload = null;
};

// 在www.script.a.com/b.html中
document.domain = 'a.com';
```

### （3）图像Ping

```js
var img=new Image();
img.onload=img.onerror=function(){...}
img.src="url?name=value";
```

请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。

图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。

缺点：只能发送GET请求；无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。

### （5）Comet

Comet可实现服务器向浏览器推送数据

Comet是实现方式：长轮询和流

- 短轮询即浏览器定时向服务器发送请求，看有没有数据更新。
- 长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。
- 流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。

### （6）WebSocket

```js
// WebSocket可在一个单独的持久连接上提供全双工、双向通信。
// WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。
var webSocket=new WebSocket("ws://");
webSocket.send(message);
webSocket.onmessage=function(event){
    var data=event.data;
    ... ...
}
```

注意：

- 必须给WebSocket构造函数传入绝对URL；
- WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；
- WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。

优点：在客户端和服务器之间发送非常少的数据，减少字节开销。

### （7）postMessage

使用HTML5的window.postMessage方法跨域：一种消息的推送，可以给每个窗口推送，然后在目标窗口添加message的监听事件从而获取推送过来的数据

## CSRF攻击

CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性，防止`csrf`常用方案如下：

- 阻止不明外域的访问：同源检测 + Samesite Cookie
- 提交时要求附加本域才能获取的信息：CSRF Token + 双重Cookie验证

详情参考：https://tech.meituan.com/2018/10/11/fe-security-csrf.html

## http和https

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

### 混合加密：机密性

对称加密 + 非对称加密：通过两个随机数计算出预主密钥，并通过非对称加密进行通信，然后通过三随机数和预主密钥计算出会话密钥，结合会话密钥使用对称加密进行通信

![image-20220322184112607](/Users/quzhengwei/Documents/GitHub/interview/images/image-20220322184112607.png)

### 摘要算法：完整性

通过散列函数、哈希函数等压缩算法在原文上附加一个 （SHA-2 的）摘要，网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改

### 数字签名：身份认证+不可否定

私钥加密，公钥解密。借助第三方CA验证机构，证明：

- 认证服务器的公开密钥的是真实有效的数字证书认证机构
- 服务器的公开密钥是值得信赖的

其认证主要流程如下：

- 服务器的运营人员向数字证书认证机构提出公开密钥的申请
- 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名（用私钥加密，而且机构的公钥已经提前植入到浏览器中）
- 然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起
- 服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信

## HTTP2.0与1.1

```json
HTTP1.0：
- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

HTTP1.1：
- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 在同一个TCP连接里面，客户端可以同时发送多个请求
- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
- 新增了一些请求方法
- 新增了一些请求头和响应头

HTTP2.0：
- 采用二进制格式而非文本格式
- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
- 使用报头压缩，降低开销
- 可让服务器可以将相应主动“推送”到客户端缓存中
```

## 计算机网络五层体系结构

物理层 -> 数据链路层 -> 网络层 -> 传输层 -> 应用层

## TCP与UDP

- TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取
- TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方
- TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
- TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信

|          | TCP                              | UDP                            |
| -------- | -------------------------------- | ------------------------------ |
| 可靠性   | 可靠                             | 不可靠                         |
| 连接性   | 面向连接                         | 无连接                         |
| 报文     | 面向字节流                       | 面向报文                       |
| 效率     | 传输效率低                       | 传输效率高                     |
| 双共性   | 全双工                           | 一对一、一对多、多对一、多对多 |
| 流量控制 | 滑动窗口                         | 无                             |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复 | 无                             |
| 传输效率 | 慢                               | 快                             |

## TCP三次握手与四次挥手

### 三次握手

1. 建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认
   1. 服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN-RECV状态
2. 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。

### 四次挥手

1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

### SYN攻击（洪泛攻击）

SYN攻击就是客户机在短时间内伪造大量不存在的IP地址，并向服务器不断地发送SYN包，服务器回复确认包，并等待客户机的确认，由于源地址是不存在的，因此，服务器需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当服务器上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。

### 为何建立连接是三次握手，而关闭连接却是四次挥手

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

### 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

2msl是最大报文生存时间

-  保证TCP协议的全双工连接能够可靠关闭
-  保证这次连接的重复数据段从网络中消失

## http状态码

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接受的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求处理完毕               |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL 适合永久重定向 302适合临时跳转
- 400  （错误请求） 服务器不理解请求的语法。
- 401  （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403  （禁止） 服务器拒绝请求。
- 404  （未找到） 服务器找不到请求的网页。
- 500 - 内部服务器错误

## IPV4 IPV6

地址：IPV4(32 IPV6(128) 位二进制数组成

## 浏览器缓存机制

![img](https://pic3.zhimg.com/v2-3e4cf399bbc70a84b426b04b7eac55ba_r.jpg)

## CDN内容分发网络

Content Delivery Network：用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器

在没有应用`CDN`时，我们使用域名访问某一个站点时的路径为

> 用户提交域名→浏览器对域名进行解释→`DNS` 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

`CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键

**负载均衡系统**

由于没有返回`IP`地址，于是本地`DNS`会向负载均衡系统再发送请求 ，则进入到`CDN`的全局负载均衡系统进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
- 看用户所在的运营商网络，找相同网络的边缘节点
- 检查边缘节点的负载情况，找负载较轻的节点
- 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的缓存代理

**缓存代理**

缓存系统是 `CDN`的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源

其中有两个衡量`CDN`服务质量的指标：

- 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
- 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户

回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源

现在的商业 `CDN`命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上

## 域名发散与域名收敛

域名发散：就是为了突破浏览器对于同一域名并发请求数的限制，使用域名发散为同一个服务申请多个域名，从而可以一定程度上提高并发量；当然，由于建立新的请求需要一定的代价，因此需要在域名发散与域名收敛间进行交换，通常发散的域名个数为2-4个；

域名收敛：就是将静态资源放在一个域名下不进行发散，这主要是为了适应移动端的发展需求；通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对移动端的用户体验是致命的，因此需要进行域名收敛

## 路由器和交换机的区别

- 路由器：寻址，转发（依靠 IP 地址），交换机：过滤，转发（依靠 MAC 地址）
- 交换机用于连接局域网，数据包在局域网内网的数据转发，路由器用于连接局域网和外网，数据包可以在不同局域网转发。
- 交换机工作于TCP/IP协议的最后一层数据链路层（物理层），路由器工作于网络层
- 交换机负责具体的数据包传输，路由器不负责包的实际传输，路由器只封装好要传输的数据包，然后交给交换机去传输（不一定是交换机，可能是其他传输技术），用java比喻大概简单理解为路由器是抽象类，定义好传输的数据包格式，交换机是具体实现类，也可以有其他实现类
- 交换机没有MAC地址和IP地址，路由器有MAC地址和IP地址（指纯碎的交换机和路由器，三层交换机是可以有IP地址的，路由器也有内置交换机功能的）
